

### Redis是什么？简单介绍一下Redis的特点。

Redis是一个开源的内存数据库，主要用于缓存和存储数据。Redis支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等，提供了丰富的数据操作命令。

Redis的特点主要包括：

- 高性能：Redis将数据保存在内存中，读写速度非常快，可以达到每秒数十万个请求。
- 丰富的数据结构：Redis支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等，可以满足不同的数据存储需求。
- 持久化存储：Redis支持将内存中的数据持久化存储到磁盘中，可确保数据不会因为断电等原因而丢失。
- 高可用性：Redis支持主从复制、哨兵等机制，可以实现高可用性的部署方案。
- 分布式：Redis可以通过分片等机制实现数据的分布式存储和访问，可以支持海量数据存储和高并发访问。
- 简单易用：Redis提供了简单易用的命令行界面和客户端API，开发和使用都非常方便。

### Redis支持哪些数据结构？各自的作用是什么？

具体使用案例见文章：[Redis+Lua脚本实现点赞功能demo](https://gulong.tech/blog/15)

Redis支持以下几种数据结构：

- 字符串(String)：字符串是Redis中最基本的数据类型，二进制安全，支持常见的字符串操作。
- 哈希(Hash)：哈希是一个键值对集合，可以将一个键映射到多个值，常用于存储对象。
- 列表(List)：列表是一个有序的字符串链表，可以在链表两端进行快速的插入和删除操作，支持根据下标访问和修剪列表。
- 集合(Set)：集合是一组无序的字符串，支持去重、添加、删除、交集、并集等操作。
- 有序集合(Sorted Set)：有序集合是一组有序的字符串，每个字符串都关联了一个分数，可以根据分数进行排序、添加、删除、范围查询等操作。

这些数据结构各自适合不同的场景，比如字符串适合存储简单的键值对、哈希适合存储对象、列表适合存储日志和消息队列、集合适合去重操作、有序集合适合存储排行榜等。

### Redis的持久化方式有哪些？它们之间有什么区别？

详细解读见文章：[Redis的数据持久化：AOF与RDB](https://gulong.tech/blog/13)

Redis的持久化方式有两种：RDB和AOF。

RDB持久化：将Redis在内存中的数据定期快照存储到磁盘中，生成一个RDB文件。RDB文件存储的是Redis在某个时间点的数据快照，可以通过载入RDB文件来恢复数据。RDB持久化通过fork子进程来创建快照，因此在创建快照时可能会阻塞主进程。

AOF持久化：将Redis执行的每个写命令追加到AOF日志中，每次Redis重启时，根据AOF日志中记录的命令重放一次，以达到恢复数据的目的。AOF持久化有三种模式，appendfsync always、appendfsync everysec和appendfsync no，分别对应每次写操作都进行同步、每秒同步一次、不同步。

两种持久化方式之间的区别如下：

存储方式：RDB持久化存储的是快照文件，而AOF持久化存储的是所有写命令。

恢复速度：RDB恢复速度快，但可能丢失数据，AOF恢复速度较慢，但能够保证数据不丢失。

数据安全：RDB持久化会定期进行快照，如果在快照之间发生宕机，数据可能会丢失。AOF持久化会将所有写命令记录到日志中，因此可以保证数据不丢失。

性能：RDB持久化的性能比AOF持久化高，但可能会丢失数据。AOF持久化可以保证数据不丢失，但性能较低。

### Redis的数据淘汰策略有哪些？分别适用于什么场景？

Redis的数据淘汰策略主要有以下几种：

1. volatile-lru：在设置了过期时间的键中，按照LRU算法淘汰最近最少使用的键。
2. volatile-ttl：在设置了过期时间的键中，按照键的剩余存活时间淘汰最近最少使用的键。
3. volatile-random：在设置了过期时间的键中，随机淘汰键。
4. allkeys-lru：在所有键中，按照LRU算法淘汰最近最少使用的键。
5. allkeys-random：在所有键中，随机淘汰键。
6. noeviction：不淘汰任何键，达到最大内存限制时，读写操作会报错。

不同淘汰策略适用于不同的场景。

- 如果应用程序的访问模式是“热点”，即只有一小部分键会被访问，可以选择volatile-lru或volatile-ttl，因为它们会优先淘汰过期时间最短或最近最少使用的键。
- 如果应用程序的访问模式是“随机”，即键的访问是随机的，可以选择volatile-random或allkeys-random。
- 如果不想淘汰任何键，可以选择noeviction，但需要注意达到最大内存限制时会报错。

### Redis如何实现分布式？有哪些主流的分布式解决方案？

Redis实现分布式主要有以下两种方式：

1. 数据分片：将数据划分为多个分片，每个节点存储其中的一部分数据，可以通过哈希函数将键映射到对应的节点进行访问。
2. 主从复制：通过将数据复制到多个节点，实现数据的备份和负载均衡。每个节点可以有多个从节点，负责复制主节点的数据。

常见的Redis分布式解决方案有以下几种：

1. Codis：使用数据分片和主从复制相结合的方式，具有高可用性和扩展性。
2. Redis Cluster：Redis官方提供的分布式解决方案，采用数据分片和节点间复制相结合的方式，可以提高可用性和扩展性。
3. Twemproxy：使用代理方式实现分布式，将请求分发到不同的Redis节点上，提高了负载均衡和可用性。
4. Redis Sentinel：使用主从复制和哨兵模式，实现Redis的高可用性。

选择哪种解决方案主要取决于实际需求和场景。如果需要高可用性和扩展性，可以选择Codis或Redis Cluster；如果只需要高可用性，可以选择Redis Sentinel。

### Redis的缓存穿透、雪崩、击穿是什么？如何解决它们？

关于这个问题的详细解读见文章：[还没写好，写好了再回来补上](https://gulong.tech/openai)

Redis的缓存穿透、雪崩、击穿是常见的缓存问题：

- 缓存穿透：指查询一个不存在的键，导致所有的请求都到后端数据库。
- 缓存雪崩：指大量的缓存数据在同一时间内失效，导致所有的请求都到后端数据库，造成数据库压力过大。
- 缓存击穿：指一个热点键失效或过期，在失效的瞬间，有大量的请求同时访问，导致所有请求都到后端数据库。

解决这些问题的方法如下：

- 缓存穿透：可以使用布隆过滤器或者在缓存中添加空值或默认值来解决，查询不存在的键时，可以直接返回空值或默认值，避免请求到后端数据库。
- 缓存雪崩：可以使用加锁、缓存预热、失效时间随机分布等方法来解决。加锁可以避免大量请求同时访问数据库，缓存预热可以提前将数据加载到缓存中，失效时间随机分布可以避免缓存同时失效。
- 缓存击穿：可以使用加锁、缓存预热、热点数据不过期等方法来解决。加锁可以避免热点键失效时，大量请求同时访问数据库，缓存预热可以提前将热点数据加载到缓存中，热点数据不过期可以保证热点数据一直在缓存中。

### Redis和Memcached的区别和联系是什么？

Redis和Memcached都是内存数据库，可以用于缓存和高速数据存储。它们的主要区别如下：

1. 数据类型：Redis支持丰富的数据类型，包括字符串、哈希、列表、集合、有序集合等，而Memcached只支持简单的键值对。
2. 持久化：Redis支持两种持久化方式RDB和AOF，而Memcached不支持持久化。
3. 性能：在数据读取方面，Redis比Memcached稍慢，但在写入方面，Redis比Memcached快得多。
4. 集群模式：Redis支持主从复制、哨兵模式和Redis Cluster等多种集群模式，而Memcached只能通过客户端库来实现集群。
5. 分布式锁：Redis支持分布式锁，而Memcached不支持。

虽然Redis和Memcached有一些不同之处，但它们也有一些共同之处：

1. 都是基于内存的数据库，读写性能极高。
2. 都可以用作缓存和高速数据存储。
3. 都支持多种编程语言，如Java、Python、PHP等。

需要根据具体的场景和需求来选择Redis和Memcached。

### Redis的线程模型是什么？为什么使用单线程模型？

关于这个问题的详细解读见文章：[还没开始写，写好了再补回来](https://gulong.tech/openai)

Redis采用单线程模型，通过IO多路复用和非阻塞IO来实现高并发和高吞吐量的访问。

Redis的单线程模型有以下优点：

1. 单线程模型避免了线程切换和竞争条件的开销，减少了系统的上下文切换开销，提高了系统的整体性能。
2. 单线程模型可以避免多线程并发访问时的竞争条件和死锁等问题，保证了系统的稳定性和可靠性。
3. Redis采用非阻塞IO和IO多路复用的技术，可以实现高并发和高吞吐量的访问，提高了系统的性能和可扩展性。
4. 单线程模型可以避免多线程并发访问时的复杂性和调试难度，降低了系统的开发和维护成本。

需要注意的是，虽然Redis是单线程模型，但是它的内部仍然使用了多个底层线程，如IO线程和后台线程等，来处理文件IO、网络IO、持久化等任务，提高了系统的性能和可靠性。

### Redis如何保证数据一致性？

Redis保证数据一致性主要有以下几种方式：

1. 主从复制：Redis通过主从复制的方式，将主节点的数据异步或同步复制到从节点，保证数据的备份和冗余。当主节点宕机时，从节点可以自动切换为主节点，保证系统的高可用性。
2. 持久化：Redis支持两种持久化方式RDB和AOF，可以在系统崩溃或重启时，将内存中的数据重新加载到磁盘中，保证数据不会丢失。RDB方式是将全量数据定期持久化到磁盘中；AOF方式是将写操作追加到文件中，可以保证数据的完整性和一致性。
3. 事务：Redis支持事务的操作，可以将多个命令打包成一个事务执行，保证多个命令的原子性和一致性。

需要注意的是，虽然Redis可以通过主从复制、持久化和事务等方式来保证数据的一致性，但是在实际应用中，由于网络延迟、系统故障等原因，还是存在数据不一致的情况。因此，在应用中需要结合具体业务场景和需求，采用多种手段来保证数据的一致性和可靠性。

### Redis集群中的master-slave同步机制是什么？如何保证数据的一致性和可靠性？

Redis集群中的master-slave同步机制基于异步复制（asynchronous replication）。当一个master节点接收到一条写命令时，它会先将这条命令写入自己的数据结构中，然后异步地将这个命令发送给所有关联的slave节点。slave节点在接收到这个命令后，会将这个命令按照相同的顺序执行，从而达到与master节点相同的数据状态。

Redis采用异步复制的机制主要是为了提升性能，因为同步复制会增加写操作的延迟，降低系统的吞吐量。同时，异步复制也具有一定的风险，因为如果master节点发生故障，可能会导致slave节点的数据落后于master节点，从而导致数据不一致。因此，Redis集群提供了多种机制来保证数据的一致性和可靠性：

- 主从节点之间会定期进行心跳检测，一旦master节点失效，会自动进行故障转移，使一个slave节点升级为新的master节点。
- Redis支持多种持久化机制，在master节点发生故障时，可以从磁盘中恢复数据，以保证数据的可靠性。
- Redis还提供了哨兵机制，可以监控Redis集群的健康状态，当发现master节点失效时，会自动进行故障转移，保证数据的一致性。

总的来说，Redis集群中的master-slave同步机制可以通过多种机制来保证数据的一致性和可靠性，从而提供高可用性的数据存储服务。

### 什么是哨兵机制

哨兵（Sentinel）是Redis官方提供的一种高可用性解决方案，是一个用于监控和管理Redis集群的进程。它可以监控Redis集群中的master和slave节点的运行状态，并在发生故障时自动进行故障转移，以保证Redis集群的高可用性。

哨兵的主要功能包括：

- 监控Redis集群中的master和slave节点，以及哨兵本身的运行状态。
- 在master节点失效时，自动选举一个新的master节点，并通知所有的slave节点切换到新的master节点。
- 在slave节点失效时，自动将其重新配置为新的slave节点，并向新的master节点进行同步。
- 提供故障检测和自动恢复的功能，可以自动发现故障，并尝试自动恢复。
- 提供CLI接口，可以监控Redis集群的运行状态，以及对Redis集群进行管理和配置。

哨兵机制可以保证Redis集群在节点失效时可以自动进行故障转移，从而保证Redis集群的高可用性。同时，哨兵还提供了CLI接口，可以方便地进行Redis集群的管理和配置。

### 如何使用哨兵机制

使用哨兵机制可以保证Redis集群的高可用性，以下是使用哨兵机制的基本步骤：

- 安装和配置Redis集群。
- 安装和配置哨兵进程。
- 配置哨兵进程监控Redis集群。
- 启动哨兵进程。
- 测试Redis集群的高可用性。

具体步骤如下：

1. 安装和配置Redis集群。

首先需要安装Redis集群，并进行配置。Redis集群配置需要指定每个节点的IP地址和端口号，以及集群的复制模式（master-slave或cluster）。可以参考Redis官方文档进行配置。

1. 安装和配置哨兵进程。

安装哨兵进程需要在Redis官网上下载哨兵安装包，并进行安装。配置哨兵进程需要指定监控的Redis集群的IP地址和端口号，以及哨兵进程的端口号等信息。可以通过编辑哨兵的配置文件来进行配置。

1. 配置哨兵进程监控Redis集群。

配置哨兵进程监控Redis集群需要指定每个Redis节点的IP地址和端口号，以及节点的角色（master或slave）。可以通过编辑哨兵的配置文件来进行配置。

1. 启动哨兵进程。

启动哨兵进程需要执行命令：redis-sentinel /path/to/sentinel.conf，其中/path/to/sentinel.conf是哨兵的配置文件路径。

1. 测试Redis集群的高可用性。

测试Redis集群的高可用性需要模拟节点失效的情况，例如停止某个Redis节点的服务，观察哨兵进程是否可以自动进行故障转移，以及Redis集群是否可以正常工作。

通过以上步骤，就可以使用哨兵机制保证Redis集群的高可用性。









**redis**：用于缓存、发布订阅、高速队列，  select 16 ，

基本数据类型：string、list、hash、set、zset ，

三种特殊数据类型：bitmap（0、1），geo，hyprologlog（基数，在误差可接受范围内快速计算基数）

redis支持事务：multe，命令入队，exec ， redis事务没有原子性

**应用场景****⭐**

1. 缓存
2. 共享Session
3. 消息队列系统，通知
4. 分布式锁

------

## 常问问题

### Redis持久化RDB快照& AOF日志/秒⭐

- RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略。 当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉。
- AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。 使用AOF做持久化，每一个写命令都通过write函数追加到appendonly.aof中。aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。 缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB）；全同步结束后，进行增量同步(AOF)。

如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 **AOF** 来重新构建数据，因为 AOF 中的**数据更加完整**。

**RDB 持久化优点**

- RDB是一个紧凑压缩的二进制文件，存储效率高， RDB恢复数据速度比AOF快

**RDB持久化缺点**

- 无法做到实时持久化，具有较大可能丢失数据
- 存储数量较大时，效率较低，I／O性能较低
- 基于fork创建子进程，内存产生额外消耗
- 宕机带来的数据丢失风险

**AOF 优点**

- AOF 可以更好的保护 数据不丢失，一般 AOF 会每隔 1 秒，最多丢失 1 秒钟的数据。
- 写入性能非常高，而且文件不容易破损
- **适合做灾难性的误删除的紧急恢复**。

**AOF 缺点**

- 对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。  恢复速度较慢

#### RDB 与 AOF 如何选择

对数据非常敏感，建议使用默认的AOF持久化方案

AOF策略使用everysec，每秒fsync一次，该策略仍可保持很好性能，出现问题最多丢失一秒内的数据

数据可以做到阶段内无丢失，且恢复较快，阶段点数据恢复通常使用RDB方案

综合：

如果不能承受分钟内的数据丢失，对业务数据非常敏感，选用AOF

如果能承受分钟内的数据丢失，且追求大数据集的恢复速度选用RDB，RDB 非常适合灾难恢复。

双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据量

------

### Redis怎么保持缓存与数据库一致性？⭐

**将不一致分为三种情况：**

**1. 数据库有数据，缓存没有数据；**

**2. 数据库有数据，缓存也有数据，数据不相等；**

**3. 数据库没有数据，缓存有数据。**

**缓存策略**：大多数人使用的策略，叫做 Cache Aside Pattern。简而言之，就是

**1. 读：首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回。**

**2. 更新： 需要更新数据时，先更新数据库，然后把缓存里对应的数据失效掉（删掉）。**

更新。如果不采取我提到的这种更新方法，你还能想到什么更新方法呢？大概会是：先删除缓存，然后再更新数据库。这么做引发的问题是，如果A,B两个线程同时要更新数据，并且A,B已经都做完了删除缓存这一步，接下来，A先更新了数据库，C线程读取数据，由于缓存没有，则查数据库，并把A更新的数据，写入了缓存，最后B更新数据库。那么缓存和数据库的值就不一致了。另外有人会问，如果采用你提到的方法，为什么最后是把缓存的数据删掉，而不是把更新的数据写到缓存里。这么做引发的问题是，如果A,B两个线程同时做数据更新，A先更新了数据库，B后更新数据库，则此时数据库里存的是B的数据。而更新缓存的时候，是B先更新了缓存，而A后更新了缓存，则缓存里是A的数据。这样缓存和数据库的数据也不一致。按照我提到的这种更新缓存的策略，理论上也是有不一致的风险的，之前在其他的博客文章有看到过，只不过概率很小，我们暂时可以不考虑，后面我们有其他手段来补救。讨论完使用缓存的策略，我们再来看这三种不一致的情况。

**1. 对于第一种，在读数据的时候，会自动把数据库的数据写到缓存，因此不一致自动消除.**

**2. 对于第二种，数据最终变成了不相等，但他们之前在某一个时间点一定是相等的（不管你使用懒加载还是预加载的方式，在缓存加载的那一刻，它一定和数据库一致）。这种不一致，一定是由于你更新数据所引发的。前面我们讲了更新数据的策略，先更新数据库，然后删除缓存。因此，不一致的原因，一定是数据库更新了，但是删除缓存失败了。**

**3. 对于第三种，情况和第二种类似，你把数据库的数据删了，但是删除缓存的时候失败了。**

**因此，最终的结论是，需要解决的不一致，产生的原因是更新数据库成功，但是删除缓存失败。**

解决方案大概有以下几种：

**1. 对删除缓存进行重试，数据的一致性要求越高，我越是重试得快。**

**2. 定期全量更新，简单地说，就是我定期把缓存全部清掉，然后再全量加载。**

**3. 给所有的缓存一个失效期。**

第三种方案可以说是一个大杀器，任何不一致，都可以靠失效期解决，失效期越短，数据一致性越高。但是失效期越短，查数据库就会越频繁。因此失效期应该根据业务来定。

**并发不高的情况：**

**读: 读redis->没有，读mysql->把mysql数据写回redis，有的话直接从redis中取；**

**写: 写mysql->成功，再写redis；**

**并发高的情况：**

**读: 读redis->没有，读mysql->把mysql数据写回redis，有的话直接从redis中取；**

**写：异步话，先写入redis的缓存，就直接返回；定期或特定动作将数据保存到mysql，可以做到多次更新，一次保存；**

无法做到强一致性：（分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。）

### 散列表和跳跃超之类的？？？

### zset跳表的数据结构⭐

增加了向前指针的链表叫作跳表跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。

原理：

跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了。

**为什么使用跳跃表**

首先，因为 zset 要支持随机的插入和删除，所以它 **不宜使用数组来实现**，关于排序问题，我们也很容易就想到 **红黑树/ 平衡树** 这样的树形结构，为什么 Redis 不使用这样一些结构呢？

1. **性能考虑：** 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部 *(下面详细说)*；
2. **实现考虑：** 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；

### redis 分布式锁-超时（Lua脚本延长锁时间）

知道分布式锁吗？有哪些实现方案？谈谈对redis分布式锁的理解，删除key 的时候有什么问题？

redis面试题：

Redis做分布式锁的时候有什么需要注意的问题？

如果redis是单点部署的，会有什么问题？怎么解决单点问题呢？

集群模式下，比如主从模式，有没有什么问题？

简单介绍一下Redlock吧？ 你简历上写redisson， 你谈谈？

Redis分布式锁如何续期？ 看门狗知道吗？

- 集群环境下，直接使用RedLock 之 Redisson 落地实现
- 并发时候会遇到，被重新抢占的错误

1. 总结：

synchronzed 单机版ok

分布式，nginx分布式微服务单机锁不行，使用redis分布式锁setnx， 只加锁没有是释放锁，如果出现异常可能无法释放锁，在finally层释放锁

宕机情况也会导致锁没有释放，需要给lockKey设置过期时间

增加过期时间必须要与 setnx同一行的原子性操作

必须规定只能删自己的锁

lua或事务， 集群环境下我们自己写的也不行， 直接使用RedLock之 Redisson 落地实现

## 其他

### Redis是什么

Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。

Redis作为一个内存数据库。  性能优秀，数据在内存中，读写速度非常快 ， 单进程单线程，是线程安全的，采用IO多路复用机制；

丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等；

支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载；

支持 主从复制，哨兵，高可用；

可以用作分布式锁；  可以作为消息中间件使用，支持发布订阅

### Redis 和 memcached 的区别

1. **redis支持更丰富的数据类型（支持更复杂的应用场景）**：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。
2. **Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。**
3. **集群模式**：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.
4. **Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。**

### redis 为什么是单线程的？

因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。 可以避免多线程上下文切换。

最新的redis6.0后是多线程

### 为什么Redis这么快？⭐

完全基于内存,绝大部分请求是纯粹的内存操作,执行效率高

采用单线程,单线程也能处理高并发请求,想多核也可启动多实例

单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。

核心是基于非阻塞的 IO 多路复用机制。

### Redis 支持的数据类型有哪些？应用？⭐

1. String字符串:字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型， Value 不仅是 String，也可以是数字。常用在缓存、计数、共享Session、限速等。
2. Hash哈希:在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车。
3. List列表（双向链表）:列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。 数据结构：List 就是链表，可以用来当消息队列用。Redis 提供了 List 的 Push 和 Pop 操作，还提供了操作某一段的 API，可以直接查询或者删除某一段的元素。 实现方式：Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。
4. Set集合：集合（set）类型也是用来保存多个的字符串元素，集合是通过 hashtable 实现的。 但和列表类型不一样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
5. Sorted Set有序集合（跳表实现）：Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。实现方式：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。

### **String 在你们项目怎么用的？**

**常用命令:** set,get,decr,incr,mget 等。

在显示某个人的基本数据的时候，比如名字，粉丝数，关注数，使用 String 保存：

```plain
eg:  user:id:3506728370  
{"id":3506728370,"name":"春晚","fans":12210862,"blogs":6164, "focus":83}
```

设置一个定时刷新的操作，这样用户不需要直接读取数据库。怎么设置？setx key   value，一定时间循环判断key是否失效，到期后再去数据库读取。

### **List 在你们项目怎么用的？**

**常用命令:** lpush,rpush,lpop,rpop,lrange等

1. 朋友圈点赞，要求按照点赞顺序显示点赞好友信息
   如果取消点赞，移除对应好友信息，但是不能使用pop了，怎么办呢？
   解决方案
   lrem key count value **移除指定数据**
   count：移除的数目
   value：具体要移除的内容
2. 个人用户的关注列表需要按照用户的关注顺序展示。

### **Set 在你们项目怎么用的？**

每位用户首次使用今日头条时会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户

对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？

**分析**

系统分析出各个分类的最新或最热点信息条目并组织成set集合

随机挑选其中部分信息

配合用户关注信息分类中的热点信息组织成展示的全信息集合

**解决方案**

- 随机获取集合中指定数量的数据
  srandmember key [count]
- 随机获取集合中的某个数据并将该数据移出集合
  spop key [count]

### **zset**项目中使用

在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。

### zset跳表的数据结构⭐

增加了向前指针的链表叫作跳表跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。

原理：

跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了。

**为什么使用跳跃表**

首先，因为 zset 要支持随机的插入和删除，所以它 **不宜使用数组来实现**，关于排序问题，我们也很容易就想到 **红黑树/ 平衡树** 这样的树形结构，为什么 Redis 不使用这样一些结构呢？

1. **性能考虑：** 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部 *(下面详细说)*；
2. **实现考虑：** 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；

### redis 设置过期时间

Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是**短信验证码都是有时间限制的**，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。

我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。

如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？

### 数据过期策略⭐

**定期删除+惰性删除。**

通过名字大概就能猜出这两个删除方式的意思了。

- **定期删除**：redis默认是每隔 100ms 就**随机抽取**一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
- **惰性删除** ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。

但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ **redis 内存淘汰机制。**

### 数据淘汰机制⭐

当内存到达最大内存限制时进行的数据淘汰策略

1. 新写入操作会报错。（Redis 默认策略）
2. 在键空间中，移除最近最少使用的 Key。（LRU推荐使用）
3. 在键空间中，随机移除某个 Key。
4. 在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。
5. 在设置了过期时间的键空间中，随机移除某个 Key。
6. 在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。

**LRU 算法实现**：1.通过双向链表来实现，新数据插入到链表头部；2.每当缓存命中（即缓存

数据被访问），则将数据移到链表头部；3.当链表满的时候，将链表尾部的数据丢弃。

LinkedHashMap：HashMap 和双向链表合二为一即是 LinkedHashMap。HashMap 是无序

的，LinkedHashMap 通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插

入顺序（默认），也可以是访问顺序。

### Redis的LRU具体实现：

传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致执行select *的时候大量非热点数据占领头部数据，所以需要改进。Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按lru大小顺序排列的。接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰。

### 为什么要用缓存？

用缓存，主要有两个用途：**高性能**、**高并发**。

- 

### redis 怎么实现分布式锁？

Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。

占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁

也可以配合`EXPIRE key seconds`自动释放锁

设置key的生存时间,当key过期时(生存时间为0) ,会被自动删除

风险/ **缺陷** ：原子性没有得到满足，所以不建议。

### 缓存雪崩

**在一个较短的时间内，缓存中较多的key集中过期或者缓存挂了**，导致了**数据库服务器崩溃**

缓存雪崩的事前事中事后的解决方案如下：

在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。如果 Redis 是集群部署，将热点数据均匀分布在不同的 Redis 库中也能避免全部失效。或者设置热点数据永不过期，有更新操作就更新缓存就好了

### 缓存穿透

**原因：**

1. Redis中大面积出现未命中
2. 出现非正常URL访问

解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

**布隆过滤器（Bloom Filter）**这个也能很好的预防缓存穿透的发生，就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查DB刷新KV再return

### 缓存击穿

缓存击穿是指一个Key非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发直接落到了数据库上，就在这个Key的点上击穿了缓存。

解决：设置热点数据永不过期，或者加上个锁就搞定了。

**假如 Redis  里面有 1  亿个 key ，其中有 10w 个 个 key  是以某个固定的已知的前缀开头的，如**

**果将它们全部找出来？**

使用 keys 指令可以扫出指定模式的 key 列表。

对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问

题？

这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一

段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指

令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客

户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。

### 实际项目中使用缓存有遇到什么问题或者会遇到什么问题你知道吗？

缓存和数据库数据一致性问题

### 主从复制

**作用：**

读写分离：master写、slave读，提高服务器的读写负载能力

负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量

故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复

数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式

高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案

**过程：**

- 从节点执行 **slaveof IP，port** 发送指令
- 主节点响应
- 从节点保存主节点信息（IP，port），建立和主节点的 Socket 连接。
- 从节点发送 Ping 信号，主节点返回 Pong，确定两边能互相通信。
- 连接建立后，主节点将所有数据发送给从节点（数据同步）。
- 主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。

**复制/数据同步过程分为两个阶段**

1. 全量复制：
   slave接收到master生成的RDB文件，先清空自身的旧数据，然后执行RDB恢复过程，然后告知master已经恢复完毕。
2. 部分复制（增量复制）
   主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。master把自己之前创建的复制缓冲区的数据发送到slave，slave接收到aof指令后执行重写操作，恢复数据。

**主从复制会存在以下问题：**

- 一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。
- 主节点的写能力受到单机的限制。
- 主节点的存储能力受到单机的限制。

**哨兵：**

哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master。

**作用：**

**监控**

不断的检查master和slave是否正常运行。

master存活检测、master与slave运行情况检测

**通知（提醒）**

当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。

**自动故障转移**

断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址

# 尚硅谷

Redis（代码ing）

Redis传统五大基本类型的应用

redis命令不区分大小写，key区分大小写

——— 帮助文档： help @类型

1. String （字符类型）
2. hash  （散列类型）
3. list  （列表类型）
4. set  （集合类型）
5. Zset  （有序集合类型）
6. Bitmap （位图类型）
7. HyperLogLog（统计）
8. GEO （地理）

### String

set key value

get key

同时设置/获取过个键值

- mset key value [key value ]
- mget key [key]

数值增减

- 递增数字 incr key
- 增加制定的整数 incrby key increment
- 递减数值 decr key
- decrby key increment

获取字符串长度

- strlen key

分布式锁

- setnx key value/ set key value [EX] [PX] [NX|XX]

应用场景

商品编号、订单号采用incr命令生成、 是否喜欢的文章

案件编号（每日更新）

### hash

数据格式： Map<String,Map<Object,object>>

- hset key field value
- Get key field
- Hmset key field value value
- Hmget key field
- 获取所有字段 hgetall key
- 获取某个key内的全部数量 hlen
- 删除一个key hdel
- 应用场景：购物车早起、当前中小厂可用

hash实现的简单购物车：

- 新增商品 hset shopcar ： uid 1024 334488 1
- hset shopcar ： uid 1024 334477 1
- 增加商品数量： hincrby shopcar： uid 1024 334477 1
- 商品总数： hlen shopcar ： uid 1024
- 全部选择： hgetall shopcar ： uid 1024

### list

向列表左边添加元素 ： lpush key value [value …]

向列表右边添加元素  rush key value [value …]

查看列表.  orange key start stop

获取列表中元素个数 llen key

应用场景： 微信文章订阅公众号

### set

添加元素: SADD key member [member ...]

删除元素: SREM key member [member ...]

获取集合中所有元素: SMEMBERS key

判断元素是否在集合中: SISMEMBERS key member

获取集合中元素个数: SCARD key

从集合中随机弹出一个元素，元素不删除: SRANDMEMBER key [数字]

从集合中随机弹出一个元素，出一个删一个: SPOP key [数字]

集合运算

- 集合差集运算A-B: SDIFF key [key ...]
- 集合交集运算AnB: SINTER key [key ...]
- 集合并集运算AuB: SUNION key [key ...]

应用： 抽奖小程序，微信朋友圈点赞，微博好友关注社交关系（共同关注的人。 我关注的人也关注他，大家的共同爱好），QQ内推可能认识的人

### zset

向有序集合中加入一个元素和该元素的分数

添加元素：ZADD score member [score member ...]

按照元素分数从小到大排序，返回索引从start到stop之间所有元素：ZRANGE key start stop [WITHSCORES]

获取元素的分数：ZSCORE key member

删除元素：ZREM key member [member ... ]

获取指定分数范围的元素：ZRANGEYsCORE key min max [WITHSCORES] [LIMIT offset count]

增加某个元素的分数：ZINCRBY key increment member

获取集合中元素的个数：ZCARD key

获得指定分数范围内的元素个数：9zCOUNT key min max

按照排名范围删除元素: ZREMRANGEBYRANK key start stop

获取元素的排名：

- 从小到大 ZRANK key member
- 从大到小 ZREVRANK key member

应用场景：根据商品销售对商品进行排序显示 ， 抖音热搜

- 官网网站首页热搜

定义商品销售排行榜（sorted set 集合），key为goods：sellsort ， 分数为商品销售数量

商品编号1001的销量是9，商品编号1002的销量是15

​	zadd goods：sellsort 9 1001 15 1002

又一个客户又买了两件商品1001， zincrby goods：sellsort 2 1001

求商品销量前10 名 zrange goods：sellsort 0 10

### redis 分布式锁-超时（Lua脚本延长锁时间）

知道分布式锁吗？有哪些实现方案？谈谈对redis分布式锁的理解，删除key 的时候有什么问题？

redis面试题：

Redis做分布式锁的时候有什么需要注意的问题？

如果redis是单点部署的，会有什么问题？怎么解决单点问题呢？

集群模式下，比如主从模式，有没有什么问题？

简单介绍一下Redlock吧？ 你简历上写redisson， 你谈谈？

Redis分布式锁如何续期？ 看门狗知道吗？

1. 单机并发版没有加锁

- 解决在单机情况下可以使用synchronized和lock来实现
- 在分布式系统中，因为竞争的线程可能不再同一个节点（同一个JVM中），所以需要一个让所有进程都能访问到的锁来实现，比如redis或者zookeeper来构建；
- 不同进程jvm层面的锁就不管用了，那么可以利用第三方的一个组件，来获取锁，未获取到锁，则阻塞当前想要运行的线程

1. nginx分布式微服务架构， 上 redis分布式锁 setnx
2. 出异常的话，可能无法释放锁，必须在代码层面finally 释放锁

- lock / unlock 必须同时出现并保证被调用

1. 宕机情况，代码层面没有走到finally，没办法保证解锁，这个key没有被删除，需要加入过期时间限定key
2. 设置key + 过期时间分开了，必须保证合成一行具备原子性
3. 张冠李戴删除了别人的锁，只能删自己的锁，不能删别人的锁
4. finally块的判断+del删除操作不是原子性， Lua脚本redis可以通过eval命令保证代码执行的原子性
5. 确保redisLock过期时间大于业务执行时间的问题， redis分布式锁 如何续期？
6. 集群CAP对比zookeeper

- redis （AP）， redis异步复制造成锁丢失，比如：主节点没来得及把刚刚set进来的这条数据给从节点就挂了，此时如果是集群模式下，就需要使用Redisson来解决
- zookeeper （CP）

1. 综上所述：

- 集群环境下，直接使用RedLock 之 Redisson 落地实现
- 并发时候会遇到，被重新抢占的错误

1. 总结：

synchronzed 单机版ok

分布式，nginx分布式微服务单机锁不行，使用redis分布式锁setnx， 只加锁没有是释放锁，如果出现异常可能无法释放锁，在finally层释放锁

宕机情况也会导致锁没有释放，需要给lockKey设置过期时间

增加过期时间必须要与 setnx同一行的原子性操作

必须规定只能删自己的锁

lua或事务， 集群环境下我们自己写的也不行， 直接使用RedLock之 Redisson 落地实现

### redis 缓存过期淘汰策略（LRU）

LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法

面试题

生产上你们的redis内存设置多少

如何配置修改redis的内存大小

如果内存满了怎么办

redis清理内存的方式？ 定期删除和惰性删除有了解么

redis缓存淘汰策略

redis的LRu了解过吗？ 可否手写一个LRu算法

redis内存满了怎么办（OOM）

- redis 默认内存多少？在哪里查看？如何设置修改？

- 查看redis最大占用内存， 配置文件 maxmemory
- redis默认内存64为操作系统不限制
- 一般生产怎么配置，内存的3/4
- 如何修改redis内存设置， 通过修改文件配置、命令修改
- 查看redis内存使用情况： info memory

- 内存打满了怎么办，没有加过期时间导致数据写满， 引出缓存淘汰机制

redis缓存淘汰策略

- redis过期的删除策略

- 定期删除：对CPU不友好用处理器性能换内存（以时间换空间）
- 惰性删除：对memory不友好，用存储空间换性能（以空间换时间）
- 上面两种都走极端

定期策略是前两种策略的折中

策略有哪些(redis6.0.8版本)

noeviction: 不会驱逐任何key

allkeys-lru: 对所有key使用LRU算法进行删除

volatile-lru: 对所有设置了过期时间的key使用LRU算法进行删除

allkeys-random: 对所有key随机删除

volatile-random: 对所有设置了过期时间的key随机删除

volatile-ttl: 删除马上要过期的key

allkeys-lfu: 对所有key使用LFU算法进行删除

volatile-lfu: 对所有设置了过期时间的key使用LFU算法进行删除

上面总结

2*4得8

2个维度

过期键中筛选

所有键中筛选

4个方面

LRU（最近最少使用）

LFU（频率最少使用）

random

ttl

8个选项

noeviction: 不会驱逐任何key

查看常用策略：

config get maxmemory-policy

config set maxmemory-policy allkeys-lru

redis的LRU了解过吗? 可否手写一个LRU算法

是什么

LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，

选择最近最久未使用的数据予以淘汰。

算法来源

https://leetcode-cn.com/problems/lru-cache/

设计思想

1 所谓缓存，必须要有读+写两个操作，按照命中率的思路考虑，写操作+读操作时间复杂度都需要为O(1)

2 特性要求分析

2.1 必须有顺序之分，以区分最近使用的和很久没用到的数据排序。

2.2 写和读操作 一次搞定。

2.3 如果容量(坑位)满了要删除最不长用的数据，每次新访问还要把新的数据插入到队头(按照业务你自己设定左右那一边是队头)

​      查找快，插入快，删除快，且还需要先后排序-------->什么样的数据结构满足这个问题?

你是否可以在O(1)时间复杂度内完成这两种操作?

如果一次就可以找到，你觉得什么数据结构最合适??

LRU的算法核心是哈希链表

本质就是HashMap+DoubleLinkedList 时间复杂度是O(1)，哈希表+双向链表的结合体

动画说明

编码手写如何实现LRU

案例01

参考LinkedHashMap

依赖JDK

案例02

不依赖JDK

