# MySQL总结



数据库

目前最为通用的 Java 和数据库交互技术就是 JDBC，最常见的开源框架基本都是构建在 JDBC 之上，

包括我们熟悉的JPA/Hibernate、MyBatis、Spring JDBC Template 等，各自都有独特的设计特点。

Hibernate 是最负盛名的 O/R Mapping 框架之一，它也是一个 JPA Provider。顾名思义，它是以对象为中心的，其强项更体现在数据库到 Java 对象的映射，可以很方便地在 Java 对象层面体现外键约束等相对复杂的关系，提供了强大的持久化功能。内部大量使用了Lazy-load等技术提高效率。并且，为了屏蔽数据库的差异，降低维护开销，Hibernate 提供了类 SQL 的 HQL，可以自动生成某种数据库特定的 SQL 语句。

Hibernate 应用非常广泛，但是过度强调持久化和隔离数据库底层细节，也导致了很多弊端，例如 HQL 需要额外的学习，未必比深入学习 SQL 语言更高效；减弱程序员对 SQL 的直接控制，还可能导致其他代价，本来一句 SQL 的事情，可能被 Hibernate 生成几条，隐藏的内部细节也阻碍了进一步的优化。

而 MyBatis 虽然仍然提供了一些映射的功能，但更加以 SQL 为中心，开发者可以侧重于 SQL 和存储过程，非常简单、直接。如果我们的应用需要大量高性能的或者复杂的 SELECT 语句等，“半自动”的 MyBatis 就会比 Hibernate 更加实用。而 Spring JDBC Template 也是更加接近于 SQL 层面，Spring 本身也可以集成 Hibernate 等 O/R Mapping 框架。



## MySQL三大范式

- 数据库三大范式， 每列不可拆分、每张表只描述一件事、列不存在对非主键的传递依赖

## 数据库并发策略

1. 乐观锁 2. 悲观锁 3. 时间戳

## **MySQL** 的乐观锁和悲观锁 ：

表锁（业务涉及的数据量大）、行锁（冲突几率小）， 页锁？ 使用场景 查表锁， 查询语句， show static like

解决事务冲突：1 加锁同步执行 ， 2 update时检查

**乐观锁**

1. 假设数据不会发生冲突，只在提交操作时检查是否违反数据完整性。
2. 乐观锁一般是为数据增加一个版本标识实现。

```plain
------事务A查询余额，此时balance=100,version=1-------
select balance,version from account where = '1';
------事务B查询余额，此时balance=100,version=1-------
select balance,version from account where id= '1';
------事务A充值100，此时num=200-------
update account set balance = balance + 100,version = version + 1 where id = 1 and version = 1; 
------事务B消费30，此时失败-------
update account set balance = balance - 30,version = version + 1 where id = 1 and version = 1;
```

**优点与不足**

- 乐观锁在失败回滚的开销较大

**悲观锁**

1. 假定数据会发生冲突，屏蔽一切可能违反数据完整性的操作。
2. 悲观锁一般利用mysql的排它锁实现。

```plain
------事务A查询余额，此时balance=100并为id=1加锁-------
select balance from account where id = '1' for update;
------事务B查询余额，此时无法加锁失败-------
select balance from account where id = '1' for update;
------事务A充值100，此时num=200-------
update account set balance = balance + 100 where id = 1;
```

**优点与不足**

- 悲观锁采用一锁二查三更新的严谨策略。
- 加锁产生额外的开销，容易产生死锁；
- 一个事务中锁定了某行数据，其他事务将等待。

## mysql间歇锁

记录锁： select * from table where id =1 for update;

间歇锁：select * from table where id between 1 and 10 for update;

- 间歇锁，锁住的一个区间，一段范围的索引记录

## **MySQL** 优化

1. 搜索引擎的优化，
2. SQL的优化：不用 in 的时候 用exist ， not exist ， 替换in ， 使用join 代替子查询
3. 索引优化：避免全表检索， where 、order by 后面建索引
4. 尽量把字段设置为not null， 设置合适的属性，
5. 表优化（缓存、索引、读写分离）

加一天

SELECT DATE_FORMAT(DATE_SUB(NOW(),INTERVAL 1 DAY),'%Y-%m-%d');

## 搜索引擎

（使用适当的搜索引擎会提高数据库的性能）

- innodb 默认搜索引擎（事务型数据库首选） ，
- MyISAM 数据仓库使用，拥有较高的插入、查询速度
- Memory 临时存储、数据量不大、安全性不高
- Archive 如果只有insert、select ，适合存储归档数据，如：记录日志

## 事务的四个特征

- 原、一、隔、持

1.事务中都成功、都失败，2.操作前后数据一致，3.事务不被其他事物干扰，4.对数据库操作是永久的

## 四种隔离级别

（A、B两个事务）

- 读未提交：事务可以看到未提交事务的执行结果，脏读，基本不使用
  读已提交：事务只能看见已提交的结果， 不可重复读事务前后读到的结果不一致
- 可重读：默认，有幻读，（select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。），解决用间歇锁 between for update
- 可串行化（Serializable）：每个读的数据行上加共享锁，幻读都没有

（参考： [https://www.cnblogs.com/jian-gao/p/10795407.html](144c064aebeb2ac27d157d24881908cd) ）

## **Mysql**事务的使用

- 开启事务 begin 、 start transaction
- 回滚事务 **rollback**
- 提交事务 **commit**

## ABA问题

一个线程把数据A变为了B，然后又重新变成了A。此时另外一个线程读取的时候，发现A没有变化，就误以为是原来的那个A。这就是有名的ABA问题。

## 搜索引擎对比

![img](https://cdn.jsdelivr.net/gh/houyaogit/Pictures@master/PicGo/20210302213958.png)

## 索引失效

1. 有or 条件
2. like 以 %开头
3. where 中索引列有运算
4. where 中索引列使用了函数
5. 复合索引未使用最左列字段
6. 需要类型转换
7. mysql觉得全表扫描更快时（数据量少）

- 什么时候没必要使用索引

1. 唯一性差
2. 频繁更新的字段
3. where中不用的字段
4. 索引使用< > 时，效果一般

## 索引优化-索引类型

b+tree ， innoDB索引数据默认 b+tree 索引 ， 验证索引 explain，

hase索引，适合等值查询不能进行范围查询，无法利用索引完成排序，建索引字段不能太多重复会发生hash碰撞，组合索引不支持最左匹配规则

b+tree索引，是一种多路平衡查询树，节点天然有序（左叶子< 父节点 < 又叶子），范围查询不需要全表扫描

（参考： [https://www.cnblogs.com/williamjie/p/11187470.html](52593001eea3912182b6c4eef62e82e9) ）

分库分表， 垂直分、水平分

读写分离， 应用层面感觉不到读写分离， 在安装的时候配置好的

## 【Mysql索引面试题】

**本文来自一位不愿意透露姓名的粉丝投稿，由Hollis整理并"还原"了面试现场。**

相信很多人对于MySQL的索引都不陌生，索引(Index)是帮助MySQL高效获取数据的数据结构。

因为索引是MySQL中比较重点的知识，相信很多人都有一定的了解，尤其是在面试中出现的频率特别高。楼主自认为自己对MySQL的索引相关知识有很多了解，而且因为最近在找工作面试，所以单独复习了很多关于索引的知识。

但是，我还是图样图森破，直到我被阿里的面试官虐过之后我才知道，自己在索引方面的知识，只是个小学生水平。

以下，是我总结的一次阿里面试中关于索引有关的问题以及知识点。

**1**

**索引概念、索引模型**

**Q：****那你能说说什么是索引吗？**

**A：**（这道题肯定难不住我啊）索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据

**Q：****那么索引具体采用的哪种数据结构呢？**

**A：**（这道题我也背过）常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树

这里我耍了一个小心机，特意说了一下索引和存储引擎有关。希望面试官可以问我一些关于存储引擎的问题。然而面试官并没有被我带跑...

**Q：****既然你提到InnoDB使用的B+ 树的索引模型，那么你知道为什么采用B+ 树吗？这和Hash索引比较起来有什么优缺点吗？**

**A：**（突然觉得这道题有点难，但是我还是凭借着自己的知识储备简单的回答上一些）因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。**所以，哈希索引只适用于等值查询的场景。**而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描

**Q：****除了上面这个范围查询的，你还能说出其他的一些区别吗？**

**A：**（这个题我回答的不好，事后百度了一下）

B+ Tree索引和Hash索引区别？

哈希索引适合等值查询，但是无法进行范围查询

哈希索引没办法利用索引完成排序

哈希索引不支持多列联合索引的最左匹配规则

如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

**2**

**聚簇索引、覆盖索引**

**Q：****刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？**

**A：**InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值

**Q：****那这两者有什么区别吗？**

**A：**（当他问我叶子节点的时候，其实我就猜到他可能要问我聚簇索引和非聚簇索引了）在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引

**Q：****那么，聚簇索引和非聚簇索引，在查询数据的时候有区别吗？**

**A：**聚簇索引查询会更快？

**Q：****为什么呢？**

**A：**因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询

**Q：****刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做\******回表\******）是所有情况都是这样的吗？非主键索引一定会查询多次吗？**

**A：**（额、这个问题我回答的不好，后来我自己查资料才知道，通过**覆盖索引**也可以只查询一次）

覆盖索引？

覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。

当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。

如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。

当我们通过SQL语句：select key2 from covering_index_sample where key1 = 'keytest';的时候，就可以通过覆盖索引查询，无需回表。

**3**

**联合索引、最左前缀匹配**

**Q：****不知道的话没关系，想问一下，你们在创建索引的时候都会考虑哪些因素呢？**

**A：**我们一般对于查询概率比较高，经常作为where条件的字段设置索引

**Q：** **那你们有用过联合索引吗？**

**A：**用过呀，我们有对一些表中创建过联合索引

**Q：****那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？**

**A：**我们把识别度最高的字段放到最前面

**Q：****为什么这么做呢？**

**A：**（这个问题有点把我问蒙了，稍微有些慌乱）这样的话可能命中率会高一点吧。。。

**Q：** **那你知道最左前缀匹配吗？**

**A：**（我突然想起来原来面试官是想问这个，怪自己刚刚为什么就没想到这个呢。）哦哦哦。您刚刚问的是这个意思啊，在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则

虽然我一开始有点懵，没有联想到最左前缀匹配，但是面试官还是引导了我。很友善。

**4**

**索引下推、查询优化**

**Q：****你们线上用的MySQL是哪个版本啊呢？**

**A：**我们MySQL是5.7

**Q：****那你知道在MySQL 5.6中，对索引做了哪些优化吗？**

**A：**不好意思，这个我没有去了解过。（事后我查了一下，有一个比较重要的 ：Index Condition Pushdown Optimization）

Index Condition Pushdown（索引下推）

MySQL 5.6引入了索引下推优化，默认开启，使用SET optimizer_switch = 'index_condition_pushdown=off';可以将其关闭。官方文档中给的例子和解释如下：

people表中（zipcode，lastname，firstname）构成一个索引

SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';

如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。

如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。

**Q：****你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？**

**A：**这个还没有统计过，除非遇到慢SQL的时候我们才会去排查

**Q：****那排查的时候，有什么手段可以知道有没有走索引查询呢？**

**A：**可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况

**Q：****那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？**

**A：**（大概记得和优化器有关，但是这个问题并没有回答好）

查询优化器？

一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。

在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。

这个成本最低的方案就是所谓的执行计划。优化过程大致如下：

1、根据搜索条件，找出所有可能使用的索引

2、计算全表扫描的代价

3、计算使用不同索引执行查询的代价

4、对比各种执行方案的代价，找出成本最低的那一个

**Q：****哦，索引有关的知识我们暂时就问这么多吧。你们线上数据的事务隔离级别是什么呀？**

**A：**(后面关于事务隔离级别的问题了，就不展开了)

**总结&感悟**

以上，就是一次面试中关于索引部分知识的问题以及我整理的答案。感觉这次面试过程中关于索引的知识，自己大概能够回答的内容占70%左右，但是自信完全答对的内容只占50%左右，看来自己索引有关的知识了解的还是不够多。

通过这次面试，发现像阿里这种大厂对于底层知识还是比较看重的，我以前以为关于索引最多也就问一下Hash和B+有什么区别，没想到最后都能问到查询优化器上面。

**最后，不管本次面试能不能通过，都非常感谢有这样一次机会，可以让自己看到自己的不足。通过这次面试，我也收获了很多东西。加油！**





### 搜索引擎：

（使用适当的搜索引擎会提高数据库的性能）

innodb 默认搜索引擎（事务型数据库首选） ，

MyISAM 数据仓库使用，拥有较高的插入、查询速度

Memory 临时存储、数据量不大、安全性不高

Archive  如果只有insert、select ，适合存储归档数据，如：记录日志

![img](https://cdn.jsdelivr.net/gh/houyaogit/Pictures@master/PicGo/1614184883513-df48b92e-f818-4c3c-b61a-0c80dd0c5ff2.png)

### 事务的四个特征

原、一、隔、持



### Mysql 事务四种隔离级别

（A、B两个事务）：   

读未提交：事务可以看到未提交事务的执行结果，脏读，基本不使用（脏读）

读已提交：事务只能看见已提交的结果， （不可重复读）事务前后读到的结果不一致

可重读：默认，有（幻读），

可串行化（Serializable）：每个读的数据行上加共享锁，幻读都没有

（参考： https://www.cnblogs.com/jian-gao/p/10795407.html ） 

![img](https://cdn.jsdelivr.net/gh/houyaogit/Pictures@master/PicGo/1614228590967-b525837c-0a45-4edd-8c7a-f439c21c63f0.png)



### Mysql事务的使用

开启事务 begin 、 start transaction

回滚事务 rollback

提交事务 commit



### MySQL 优化 

搜索引擎的优化， 

SQL的优化：

不用 in 的时候 用exist ， not exist ， 替换in ， 

避免全表检索， 

where 、order by 后面建索引

尽量把字段设置未not null， 设置合适的属性， 

使用join 代替子查询

表优化（缓存、索引、读写分离）

索引优化， 索引类型， 

innoDB索引数据默认 b+tree 索引 ， 验证索引 explain，

hase索引，适合等值查询不能进行范围查询，无法利用索引完成排序，建索引字段不能太多重复会发生hash碰撞，组合索引不支持最左匹配规则

b+tree索引，是一种多路平衡查询树，节点天然有序（左叶子< 父节点 < 又叶子），范围查询不需要全表扫描

（参考： https://www.cnblogs.com/williamjie/p/11187470.html ） 

分库分表， 垂直分、水平分

读写分离， 应用层面感觉不到读写分离， 在安装的时候配置好的



**MySQL 的锁** ： 

表锁（业务涉及的数据量大）、行锁（冲突几率小）， 页锁？ 使用场景 查表锁， 查询语句， show static like 



乐观锁

悲观锁



ABA问题







**Q：****刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？**

**Q：****那这两者有什么区别吗？**

**Q：****那么，聚簇索引和非聚簇索引，在查询数据的时候有区别吗？**

**Q：****为什么呢？** 

**Q：****刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做****回表****）是所有情况都是这样的吗？非主键索引一定会查询多次吗？**

**A：（额、这个问题我回答的不好，后来我自己查资料才知道，通过覆盖索引也可以只查询一次）**

 

**覆盖索引？**

**覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。**

**当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。**

**如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。**

**当我们通过SQL语句：select key2 from covering_index_sample where key1 = 'keytest';的时候，就可以通过覆盖索引查询，无需回表。**



**联合索引、最左前缀匹配**



**Q：****那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？** 

**A：**（大概记得和优化器有关，但是这个问题并没有回答好）











# 